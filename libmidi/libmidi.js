// helpers
console.log('üîß LIBMIDI.JS: –ú–æ–¥—É–ª—å –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è...');

export function unlockAudioContext(audioCtx) {
    if (audioCtx.state !== 'suspended') return;
    const b = document.body;
    const events = ['touchstart','touchend', 'mousedown','keydown'];
    events.forEach(e => b.addEventListener(e, unlock, false));
    function unlock() { audioCtx.resume().then(clean); }
    function clean() { events.forEach(e => b.removeEventListener(e, unlock)); }
}

export function createUnlockingAudioContext(...params) {
    const ac = new AudioContext(...params); // params?
    unlockAudioContext(ac);
    return ac;
}

export function closeContext(ctx) {
    return ctx.close();
}

export class LibMidi {
    constructor(context, destination=null) {
        console.log('üéµ LibMidi.constructor: –°–æ–∑–¥–∞–Ω–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞');
        this.context = context;
        this.destination = destination || context.destination;
        this.initialized = false;
        this._midiPlayer = null;
        console.log('üéµ LibMidi.constructor: –≠–∫–∑–µ–º–ø–ª—è—Ä —Å–æ–∑–¥–∞–Ω', this);
    }

    async init() {
        console.log('üéµ LibMidi.init: –ù–∞—á–∏–Ω–∞–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é');
        if (this.initialized) {
            console.warn('‚ö†Ô∏è LibMidi.init: –£–∂–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
            throw new Error("LibMidi already initialized");
        }

        if (!this.context.audioWorklet || typeof AudioWorkletNode === 'undefined') {
            console.error('‚ùå LibMidi.init: AudioWorklet –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è');
            throw new Error("AudioWorklet not supported");
        }

        console.log('üéµ LibMidi.init: –ó–∞–≥—Ä—É–∂–∞–µ–º worklet –º–æ–¥—É–ª—å');
        const modulePath = new URL('./worklet.js', import.meta.url);
        await this.context.audioWorklet.addModule(modulePath);
        console.log('‚úÖ LibMidi.init: Worklet –º–æ–¥—É–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω');

        console.log('üéµ LibMidi.init: –ó–∞–≥—Ä—É–∂–∞–µ–º WASM –º–æ–¥—É–ª—å');
        const wasmPath = new URL('./libmidi.wasm', import.meta.url);
        const wasmResponse = await fetch(wasmPath);
        const wasmModule = await WebAssembly.compile(await wasmResponse.arrayBuffer());
        console.log('‚úÖ LibMidi.init: WASM –º–æ–¥—É–ª—å —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω');

        console.log('üéµ LibMidi.init: –°–æ–∑–¥–∞–µ–º bootstrap —É–∑–µ–ª');
        const bootstrapNode = new AudioWorkletNode(this.context, 'bootstrap', {
            outputChannelCount: [2],
            processorOptions: {
                module: wasmModule
            }
        });

        console.log('üéµ LibMidi.init: –û–∂–∏–¥–∞–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é WASM');
        await new Promise((resolve, reject) => {
            bootstrapNode.port.onmessage = e => {
                if (e.data.ok) {
                    console.log('‚úÖ LibMidi.init: WASM –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
                    resolve();
                } else {
                    console.error('‚ùå LibMidi.init: –û—à–∏–±–∫–∞ WASM', e.data.error);
                    reject(e.data.error);
                }
            };
        });

        this.initialized = true;
        console.log('‚úÖ LibMidi.init: LibMidi –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
    }

    async close() {
        if (this._midiPlayer) {
            this._midiPlayer.close();
            this._midiPlayer = null;
        }

        this.initialized = false;
    }

    get midiPlayer() {
        console.log('üéµ LibMidi.get midiPlayer: –ó–∞–ø—Ä–æ—Å –ø–ª–µ–µ—Ä–∞, initialized=' + this.initialized);
        if (this.initialized && !this._midiPlayer) {
            console.log('üéµ LibMidi.get midiPlayer: –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π MIDIPlayer');
            this._midiPlayer = new MIDIPlayer(this.context, this.destination);
            console.log('‚úÖ LibMidi.get midiPlayer: MIDIPlayer —Å–æ–∑–¥–∞–Ω', this._midiPlayer);
        } else if (!this.initialized) {
            console.warn('‚ö†Ô∏è LibMidi.get midiPlayer: LibMidi –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
        } else {
            console.log('üéµ LibMidi.get midiPlayer: –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –ø–ª–µ–µ—Ä');
        }

        return this._midiPlayer;
    }
}

// todo: we could make this bidirectional with methods and events, but at this point no need to do so
class CmdClient {
    constructor(port) {
        this.port = port;
        this.messageCounter = 0;
        this.pendingMessages = {};
        this._messageHandler = this._handleMessage.bind(this);
        this.port.addEventListener('message', this._messageHandler);
    }

    send(what, transfer=[]) {
        const msgId = ++this.messageCounter;
        return new Promise((resolve, reject) => {
            this.pendingMessages[msgId] = { resolve, reject };
            this.port.postMessage({ ...what, msgId }, transfer);
        });
    }

    _handleMessage(event) {
        const data = event.data;
        if (data && data.replyFor) {
            const { replyFor, value, error } = data;
            const handlers = this.pendingMessages[replyFor];

            if (handlers) {
                if (error !== undefined) {
                    handlers.reject(error);
                } else {
                    handlers.resolve(value);
                }
                delete this.pendingMessages[replyFor];
            }
        }
    }

    close() {
        // –û—á–∏—â–∞–µ–º –≤—Å–µ –æ–∂–∏–¥–∞—é—â–∏–µ –ø—Ä–æ–º–∏—Å—ã
        for (const handlers of Object.values(this.pendingMessages)) {
            handlers.reject(new Error('Client closed'));
        }
        this.pendingMessages = {};
        
        // –£–¥–∞–ª—è–µ–º —Å–ª—É—à–∞—Ç–µ–ª—å —Å–æ–±—ã—Ç–∏–π
        if (this.port && this._messageHandler) {
            this.port.removeEventListener('message', this._messageHandler);
        }
    }
}

export class MIDIPlayer extends EventTarget {
    // this MUST be explicitly closed
    // but only one instance is needed to emulate a MIDI device

    static _unregister = ([client, node, gainNode]) => {
        client.send({cmd: "delete"});
        node.disconnect();
        gainNode.disconnect();
    };

    static _finalizer = new FinalizationRegistry(args => {
        console.warn('closing midiplayer via finalizer');

        this._unregister(args);
    });

    static playerCount = 0;

    constructor(audioContext, destination) {
        super();

        console.log('üéµ MIDIPlayer.constructor: –°–æ–∑–¥–∞–Ω–∏–µ –ø–ª–µ–µ—Ä–∞');

        MIDIPlayer.playerCount++;
        this.playerId = MIDIPlayer.playerCount;
        console.log('üéµ MIDIPlayer.constructor: playerId=' + this.playerId);

        if (!audioContext.audioWorklet || typeof AudioWorkletNode === 'undefined') {
            console.error('‚ùå MIDIPlayer.constructor: AudioWorklet –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è');
            return;
        }

        console.log('üéµ MIDIPlayer.constructor: –°–æ–∑–¥–∞–µ–º gain —É–∑–µ–ª');
        this.gainNode = audioContext.createGain();
        this.gainNode.gain.value = 1;
        this.gainNode.connect(destination);

        console.log('üéµ MIDIPlayer.constructor: –°–æ–∑–¥–∞–µ–º worklet —É–∑–µ–ª');
        this.node = new AudioWorkletNode(audioContext, 'midi-player', {
            outputChannelCount: [2]
        });
        this.node.connect(this.gainNode);
        this.client = new CmdClient(this.node.port);

        const weakThis = new WeakRef(this); // it got crazy pretty fast..

        this.node.port.onmessage = e => {
            if (e.data?.replyFor) return; // these are for client.. should we use cancel?

            if (e.data === 'end-of-media') {
                console.log('üéµ MIDIPlayer: End-of-media —Å–æ–±—ã—Ç–∏–µ –ø–æ–ª—É—á–µ–Ω–æ –∏–∑ worklet');
                console.log('üéµ MIDIPlayer: Stack trace:', new Error().stack);
                console.log('üéµ MIDIPlayer: –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è');
                
                const player = weakThis.deref();
                if (player) {
                    // –û—Ç–º–µ—á–∞–µ–º, —á—Ç–æ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –¥–æ—à–ª–∞ –¥–æ –∫–æ–Ω—Ü–∞
                    player._hasEndedOnce = true;

                    // –ü—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ–±—ã—Ç–∏–µ –¥–∞–ª—å—à–µ (–º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è Java-–∫–æ–¥–æ–º)
                    player.dispatchEvent(new Event('end-of-media'));
                }
            }
        };

        this.duration = 0;

        MIDIPlayer._finalizer.register(this, [this.client, this.node, this.gainNode], this);
        console.log('‚úÖ MIDIPlayer.constructor: –ü–ª–µ–µ—Ä —Å–æ–∑–¥–∞–Ω —É—Å–ø–µ—à–Ω–æ');

        // –§–ª–∞–≥, —É–∫–∞–∑—ã–≤–∞—é—â–∏–π —á—Ç–æ –ø–ª–µ–µ—Ä —É–∂–µ –¥–æ—à—ë–ª –¥–æ –∫–æ–Ω—Ü–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —Ä–∞–∑
        this._hasEndedOnce = false;
    }

    // this is just relays the promise
    send(what, transfer=[]) {
        return this.client && this.client.send(what, transfer);
    }

    async setSequence(buffer) {
        console.log('üéµ MIDIPlayer.setSequence: –ü–æ–ª—É—á–µ–Ω buffer', buffer.byteLength + ' –±–∞–π—Ç');
        // –ö–µ—à–∏—Ä—É–µ–º –±—É—Ñ–µ—Ä, —á—Ç–æ–±—ã –º–æ–∂–Ω–æ –±—ã–ª–æ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ –µ–≥–æ –ø–æ–≤—Ç–æ—Ä–Ω–æ –±–µ–∑ —è–≤–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞ –∏–∑ Java
        this._lastSequence = buffer.slice ? buffer.slice(0) : buffer; // ArrayBuffer –∏–º–µ–µ—Ç slice
        // –§–ò–ö–°: –ü—Ä–∞–≤–∏–ª—å–Ω–æ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–ª–µ–µ—Ä –ø–µ—Ä–µ–¥ –Ω–æ–≤–æ–π –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é
        // –í–∞–∂–Ω–æ: –≤—Å–µ –∫–æ–º–∞–Ω–¥—ã –¥–æ–ª–∂–Ω—ã –≤—ã–ø–æ–ª–Ω—è—Ç—å—Å—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ —Å –æ–∂–∏–¥–∞–Ω–∏–µ–º
        console.log('üéµ MIDIPlayer.setSequence: –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ');
        await this.send({cmd: "stop"});
        console.log('üéµ MIDIPlayer.setSequence: –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ü–∏–∫–ª—ã');
        await this.send({cmd: "loop", times: 0});
        
        // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –Ω–∞ –Ω–∏–∑–∫–æ–º —É—Ä–æ–≤–Ω–µ
        await new Promise(resolve => setTimeout(resolve, 10));
        
        console.log('üéµ MIDIPlayer.setSequence: –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤ worklet');
        const { duration } = await this.send({cmd: "setSequence", buffer});
        this.duration = duration;
        console.log('‚úÖ MIDIPlayer.setSequence: –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞, duration=' + duration);
    }

    play() {
        console.log('üéµ MIDIPlayer.play: –ó–∞–ø—É—Å–∫ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è');
        console.log('üéµ MIDIPlayer.play: Stack trace:', new Error().stack);

        if (this._hasEndedOnce) {
            console.log('üéµ MIDIPlayer.play: _hasEndedOnce=true ‚Äì –ø–µ—Ä–µ—É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å');
            this._hasEndedOnce = false;

            // –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π —Ä–µ—Å–µ—Ç: stop ‚Üí setSequence(–ø–æ—Å–ª–µ–¥–Ω–∏–π_–±—É—Ñ–µ—Ä) ‚Üí play
            // –ï—Å–ª–∏ –ø–æ –∫–∞–∫–∏–º-—Ç–æ –ø—Ä–∏—á–∏–Ω–∞–º –±—É—Ñ–µ—Ä–∞ –Ω–µ—Ç (–Ω–µ –≤—ã–∑—ã–≤–∞–ª–∏ setSequence), –ø—Ä–æ—Å—Ç–æ seek –Ω–∞ 0
            (async () => {
                try {
                    await this.send({cmd: "stop"});
                    if (this._lastSequence) {
                        console.log('üéµ MIDIPlayer.play: –û—Ç–ø—Ä–∞–≤–ª—è–µ–º setSequence –ø–æ–≤—Ç–æ—Ä–Ω–æ');
                        await this.send({cmd: "setSequence", buffer: this._lastSequence});
                    } else {
                        await this.send({cmd: "seek", pos: 0});
                    }
                    await this.send({cmd: "play"});
                } catch (err) {
                    console.warn('üéµ MIDIPlayer.play: –û—à–∏–±–∫–∞ –ø—Ä–∏ auto-reset:', err);
                }
            })();
        } else {
            this.send({cmd: "play"});
        }

        console.log('‚úÖ MIDIPlayer.play: –ö–æ–º–∞–Ω–¥–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –≤ worklet');
    }

    loop(times) {
        console.log('üéµ MIDIPlayer.loop: times=' + times);
        this.send({cmd: "loop", times});
    }

    stop() {
        console.log('üéµ MIDIPlayer.stop: –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è');
        this.send({cmd: "stop"});
        console.log('‚úÖ MIDIPlayer.stop: –ö–æ–º–∞–Ω–¥–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –≤ worklet');
    }

    shortEvent(status, data1, data2) {
        this.send({cmd: "shortEvent", status, data1, data2});
    }

    // async
    getPosition() {
        return this.send({cmd: "getPosition"});
    }

    seek(pos) {
        return this.send({cmd: "seek", pos});
    }

    close() {
        // –û—á–∏—â–∞–µ–º —Å–ª—É—à–∞—Ç–µ–ª–∏ —Å–æ–±—ã—Ç–∏–π
        this.removeAllListeners();
        
        // –ó–∞–∫—Ä—ã–≤–∞–µ–º client —Å –æ—á–∏—Å—Ç–∫–æ–π —Å–ª—É—à–∞—Ç–µ–ª–µ–π
        if (this.client) {
            this.client.close();
        }
        
        // –û—Ç–∫–ª—é—á–∞–µ–º –∞—É–¥–∏–æ –Ω–æ–¥—ã
        if (this.node) {
            this.node.disconnect();
        }
        if (this.gainNode) {
            this.gainNode.disconnect();
        }
        
        // –£–¥–∞–ª—è–µ–º –∏–∑ —Ñ–∏–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä–∞
        MIDIPlayer._finalizer.unregister(this);
        
        // –û–±–Ω—É–ª—è–µ–º —Å—Å—ã–ª–∫–∏
        this.client = null;
        this.node = null;
        this.gainNode = null;
    }

    get volume() {
        return this.gainNode.gain.value;
    }

    set volume(v) {
        this.gainNode.gain.value = v;
    }

    removeAllListeners() {
        // –£–¥–∞–ª—è–µ–º –≤—Å–µ —Å–ª—É—à–∞—Ç–µ–ª–∏ —Å–æ–±—ã—Ç–∏–π
        const events = ['end-of-media'];
        events.forEach(eventType => {
            // –ö–ª–æ–Ω–∏—Ä—É–µ–º —Å–ª—É—à–∞—Ç–µ–ª–∏ —á—Ç–æ–±—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ –∏—Ö —É–¥–∞–ª–∏—Ç—å
            const listeners = this.getEventListeners ? this.getEventListeners(eventType) : [];
            listeners.forEach(listener => {
                this.removeEventListener(eventType, listener);
            });
        });
    }
}
